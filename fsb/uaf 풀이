uaf 풀이

동적할당을 통해 메모리를 사용할 경우에

TEST를 할당 후 해제하고, string이라는 변수를 다시 재 할당해 사용한다고 생각해보자.
TEST가 free된 다음, 같은 메모리 위치에 string이 할당되는데 
string을 새로 할당해 사용 하는 중 , test의 원래 멤버 변수 중에서
 print라는 함수 포인터를 참조해 사용하고 있었으면 해당 위치에 있는 포인터 값을 덮을 수 있게 된다. 
이후 할당 해제했던 test의 함수 포인터를 호출하게 되면 해당 위치에 원래 있던 값이 아닌, 
할당 해제 한 다음 string에서 새로 할당한 값이 호출되게 된다. 

디버거로 봐야 할 곳은 스택에 올라가는 해당 메모리의 주소값. 

코드의 진행을 보면, 맨 처음에 User 구조체를 동적할당으로 선언하여 heap이라는 이름으로 80바이트 만큼의 메모리를 줬다. 
그 다음, heap 구조체의 HI 함수가 hi 함수를 호출하게끔 포인터를 지정해준다. 
그 후 입력을 받을때 heap 구조체의 name 변수에 입력받은 값을 저장하게 되어있는데
어셈 상에서는 스택의 특정 위치에 heap->name 의 주소값을 올린 후, 그 주소를 참조하게끔 해준걸로 보이고 있다.

인자로 넘어가는게 맨 처음 할당 전엔 $ebp-0x10, 이후에는 $ebp-0xc 이다.

해당 부분들을 할당 해제 전 시점에서 보면 같은 주소값을 가리키고 있는것을 확인할 수 있다. 
또한, 특정 주소 위치(80번째 바이트 위치) 에 User 구조체 내의 hi 함수의 주소값도 가지고 있음이 보인다.  

해당 메모리인 0x09b9e008 위치에 0x08048544 가 고정적으로 박혀있는게 확인된다.
해당 주소는 User 구조체의 hi 함수로 가는 주소인것도 보인다. 

이러면 이제, 80바이트를 채워서 메모리 영역을 민 다음에 내가 실행하고자 하는 함수의 주소값을 넣게되면 그대로 실행 될거다. 

secret 함수의 주소 0x0804852b 를 찾아온 다음 , 두번째 입력 받을때에 넣어줘 보자.

풀이 완료.


